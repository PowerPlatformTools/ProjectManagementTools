"use strict";
// Copyright (C) Microsoft Corporation. All rights reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCommonAppStartProperties = exports.parseBooleanEnvironmentVariable = exports.tryParseAutomationAgentStringProductNameVersion = exports.isSupportedAgentProductVersion = exports.composeAutomationAgentString = void 0;
var TelemetryConstants = require("./TelemetryConstants");
var MaxAutomationAgentLength = 64;
// This is a limited char set than is supported with HTTP User-Agent for now, as in practice, most symbols aren't used for user agents.
// However, we do want to allow for using package names (nuget, npm, etc), .net assembly names, etc.
var ProductNameRegex = /^[a-zA-Z0-9.+_-]+$/;
var SystemVersionRegex = /^\d+(\.\d+){1,3}$/;
function composeAutomationAgentString(productName, productVersion) {
    if (!productName)
        throw new Error("productName must be specified.");
    if (!productVersion)
        throw new Error("productVersion must be specified.");
    if (!ProductNameRegex.test(productName)) {
        throw new Error("productName '" + productName + "' is invalid; only the following characters are allowed: letters, numbers, and the symbols '.', '+', '_', '-'.");
    }
    if (!isSupportedAgentProductVersion(productVersion)) {
        throw new Error("productVersion '" + productVersion + "' is invalid; it should be a valid System.Version or SemVer (v2).");
    }
    return productName + "/" + productVersion;
}
exports.composeAutomationAgentString = composeAutomationAgentString;
function isSupportedAgentProductVersion(productVersion) {
    if (!!productVersion) {
        // For simplicity, we ignore all content after the SemVer pre-release tag (-) or build metadata (+)
        var idxPreRelease = productVersion.indexOf('-');
        var idxMetadata = productVersion.indexOf('+');
        var idxPreReleaseOrMetadata = idxPreRelease < 0 ? idxMetadata
            : idxMetadata < 0 ? idxPreRelease
                : Math.min(idxPreRelease, idxMetadata);
        var versionSubStr = idxPreReleaseOrMetadata === -1 ? productVersion : productVersion.substring(0, idxPreReleaseOrMetadata);
        return versionSubStr.length >= 1 && SystemVersionRegex.test(versionSubStr);
    }
    return false;
}
exports.isSupportedAgentProductVersion = isSupportedAgentProductVersion;
function tryParseAutomationAgentStringProductNameVersion(agent) {
    if (!agent)
        throw new Error("agent must be specified.");
    var firstProduct = agent.split(' ', 2)[0];
    if (firstProduct.length > MaxAutomationAgentLength) {
        return {
            success: false,
            invalidReason: "The first product (name and version) has a length of " + firstProduct.length + " which is longer than allowed length of " + MaxAutomationAgentLength + ".",
        };
    }
    var parts = firstProduct.split('/');
    if (parts.length !== 2) { // both parts are required
        return {
            success: false,
            invalidReason: "Missing '/' character.",
        };
    }
    var productName = parts[0];
    if (!productName
        || !ProductNameRegex.test(productName)) {
        return {
            success: false,
            invalidReason: "Product name is empty or contains characters other than alpha-numeric and '.', '+', '_', '-'.",
        };
    }
    var productVersion = parts[1];
    if (!isSupportedAgentProductVersion(productVersion)) {
        return {
            success: false,
            invalidReason: "Product version is empty or is not a valid System.Version or SemVer (v2).",
        };
    }
    return {
        success: true,
        firstProductName: productName,
        firstProductVersion: productVersion,
    };
}
exports.tryParseAutomationAgentStringProductNameVersion = tryParseAutomationAgentStringProductNameVersion;
function validateAndSanitizeAutomationAgent(environment) {
    if (!environment.automationAgent) {
        return undefined;
    }
    var result = tryParseAutomationAgentStringProductNameVersion(environment.automationAgent);
    if (result.success !== true) {
        // We throw here because otherwise this corrupts our ability to have accurate telemetry based on automationAgent
        throw new Error("[AppTelemetryConfigurationException] The automationAgent '" + environment.automationAgent + "' is invalid. " + result.invalidReason + " This exception should be considered a developer bug of the calling agent.");
    }
    var agent = environment.automationAgent;
    // We want to limit open-ended values which could come outside our system.
    // Try shortening it to just the first product/version if it's original text is too long
    if (agent.length > MaxAutomationAgentLength) {
        // we add a comment to indicate in telemetry that it's truncated. This is per the HTTP spec
        agent = composeAutomationAgentString(result.firstProductName, result.firstProductVersion) + " --truncated--";
    }
    return agent;
}
function parseBooleanEnvironmentVariable(value) {
    if (value) {
        if (value === "1" || value.toUpperCase() === "TRUE") {
            return true;
        }
        if (value === "0" || value.toUpperCase() === "FALSE") {
            return false;
        }
    }
    return undefined;
}
exports.parseBooleanEnvironmentVariable = parseBooleanEnvironmentVariable;
function createCommonAppStartProperties(environment) {
    var properties = {};
    var agent = validateAndSanitizeAutomationAgent(environment);
    if (!agent) {
        properties[TelemetryConstants.PropertyNames.automationAgent] = agent;
    }
    return properties;
}
exports.createCommonAppStartProperties = createCommonAppStartProperties;
