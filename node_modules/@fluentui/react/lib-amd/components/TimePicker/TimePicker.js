define(["require", "exports", "tslib", "react", "../../Utilities", "@fluentui/date-time-utilities", "../../ComboBox"], function (require, exports, tslib_1, React, Utilities_1, date_time_utilities_1, ComboBox_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimePicker = void 0;
    var REGEX_SHOW_SECONDS_HOUR_12 = /((1[0-2]|0?[1-9]):([0-5][0-9]):(?:[0-5]\d) ?([AaPp][Mm]))$/;
    var REGEX_HIDE_SECONDS_HOUR_12 = /((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))$/;
    var REGEX_SHOW_SECONDS_HOUR_24 = /([0-9]|0[0-9]|1[0-9]|2[0-3]):(?:[0-5]\d):(?:[0-5]\d)$/;
    var REGEX_HIDE_SECONDS_HOUR_24 = /([0-9]|0[0-9]|1[0-9]|2[0-3]):(?:[0-5]\d)$/;
    var TIME_LOWER_BOUND = 0;
    var TIME_UPPER_BOUND = 23;
    var getDefaultStrings = function (useHour12, showSeconds) {
        var errorMessageToDisplay = '';
        var hourUnits = useHour12 ? '12-hour' : '24-hour';
        showSeconds
            ? (errorMessageToDisplay = "TimePicker format must be valid and in the " + hourUnits + " " + "format hh:mm:ss A.")
            : (errorMessageToDisplay = "TimePicker format must be valid and in the " + hourUnits + " " + "format hh:mm A.");
        return {
            invalidInputErrorMessage: errorMessageToDisplay,
        };
    };
    var TimePicker = function (_a) {
        var label = _a.label, _b = _a.increments, increments = _b === void 0 ? 30 : _b, _c = _a.showSeconds, showSeconds = _c === void 0 ? false : _c, _d = _a.allowFreeform, allowFreeform = _d === void 0 ? true : _d, _e = _a.useHour12, useHour12 = _e === void 0 ? false : _e, timeRange = _a.timeRange, _f = _a.strings, strings = _f === void 0 ? getDefaultStrings(useHour12, showSeconds) : _f, onFormatDate = _a.onFormatDate, onValidateUserInput = _a.onValidateUserInput, onChange = _a.onChange, rest = tslib_1.__rest(_a, ["label", "increments", "showSeconds", "allowFreeform", "useHour12", "timeRange", "strings", "onFormatDate", "onValidateUserInput", "onChange"]);
        var _g = React.useState(''), userText = _g[0], setUserText = _g[1];
        var _h = React.useState(''), errorMessage = _h[0], setErrorMessage = _h[1];
        var optionsCount = getDropdownOptionsCount(increments, timeRange);
        var timePickerOptions = React.useMemo(function () {
            var optionsList = Array(optionsCount);
            for (var i = 0; i < optionsCount; i++) {
                optionsList[i] = 0;
            }
            var defaultTime = generateDefaultTime(increments, timeRange);
            return optionsList.map(function (_, index) {
                var option = date_time_utilities_1.addMinutes(defaultTime, increments * index);
                option.setSeconds(0);
                var optionText = onFormatDate ? onFormatDate(option) : date_time_utilities_1.formatTimeString(option, showSeconds, useHour12);
                return {
                    key: optionText,
                    text: optionText,
                };
            });
        }, [timeRange, increments, optionsCount, showSeconds, onFormatDate, useHour12]);
        var _j = React.useState(timePickerOptions[0].key), selectedKey = _j[0], setSelectedKey = _j[1];
        var onInputChange = React.useCallback(function (event, option, index, value) {
            if (onChange) {
                onChange(event, option, index, value);
            }
            var validateUserInput = function (userInput) {
                var errorMessageToDisplay = '';
                var regex;
                if (useHour12) {
                    regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_12 : REGEX_HIDE_SECONDS_HOUR_12;
                }
                else {
                    regex = showSeconds ? REGEX_SHOW_SECONDS_HOUR_24 : REGEX_HIDE_SECONDS_HOUR_24;
                }
                if (!regex.test(userInput)) {
                    errorMessageToDisplay = strings.invalidInputErrorMessage;
                }
                return errorMessageToDisplay;
            };
            var key = option === null || option === void 0 ? void 0 : option.key;
            var updatedUserText = '';
            var errorMessageToDisplay = '';
            if (value) {
                if (allowFreeform && !option) {
                    if (!onFormatDate) {
                        // Validate only if user did not add onFormatDate
                        errorMessageToDisplay = validateUserInput(value);
                    }
                    else {
                        // Use user provided validation if onFormatDate is provided
                        if (onValidateUserInput) {
                            errorMessageToDisplay = onValidateUserInput(value);
                        }
                    }
                }
                updatedUserText = value;
            }
            else if (option) {
                updatedUserText = option.text;
            }
            setErrorMessage(errorMessageToDisplay);
            setUserText(updatedUserText);
            setSelectedKey(key);
        }, [
            allowFreeform,
            onFormatDate,
            onValidateUserInput,
            showSeconds,
            useHour12,
            onChange,
            strings.invalidInputErrorMessage,
        ]);
        var evaluatePressedKey = function (event) {
            if (!onFormatDate &&
                // Only permit input of digits, space, colon, A/P/M characters
                !((event.charCode >= Utilities_1.KeyCodes.zero && event.charCode <= Utilities_1.KeyCodes.colon) ||
                    event.charCode === Utilities_1.KeyCodes.space ||
                    event.charCode === Utilities_1.KeyCodes.a ||
                    event.charCode === Utilities_1.KeyCodes.m ||
                    event.charCode === Utilities_1.KeyCodes.p)) {
                event.preventDefault();
            }
        };
        return (React.createElement(ComboBox_1.ComboBox, tslib_1.__assign({}, rest, { allowFreeform: allowFreeform, selectedKey: selectedKey, label: label, errorMessage: errorMessage, options: timePickerOptions, onChange: onInputChange, text: userText, 
            //eslint-disable-next-line
            onKeyPress: evaluatePressedKey })));
    };
    exports.TimePicker = TimePicker;
    exports.TimePicker.displayName = 'TimePicker';
    var clampTimeRange = function (timeRange) {
        return {
            start: Math.min(Math.max(timeRange.start, TIME_LOWER_BOUND), TIME_UPPER_BOUND),
            end: Math.min(Math.max(timeRange.end, TIME_LOWER_BOUND), TIME_UPPER_BOUND),
        };
    };
    var generateDefaultTime = function (increments, timeRange) {
        var newDefaultTime = new Date();
        if (timeRange) {
            var clampedTimeRange = clampTimeRange(timeRange);
            newDefaultTime.setHours(clampedTimeRange.start);
        }
        return date_time_utilities_1.ceilMinuteToIncrement(newDefaultTime, increments);
    };
    var getDropdownOptionsCount = function (increments, timeRange) {
        var hoursInRange = date_time_utilities_1.TimeConstants.HoursInOneDay;
        if (timeRange) {
            var clampedTimeRange = clampTimeRange(timeRange);
            if (clampedTimeRange.start > clampedTimeRange.end) {
                hoursInRange = date_time_utilities_1.TimeConstants.HoursInOneDay - timeRange.start - timeRange.end;
            }
            else if (timeRange.end > timeRange.start) {
                hoursInRange = timeRange.end - timeRange.start;
            }
        }
        return Math.floor((date_time_utilities_1.TimeConstants.MinutesInOneHour * hoursInRange) / increments);
    };
});
//# sourceMappingURL=TimePicker.js.map