// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

"use strict";

const XRM_SDK_NAMESPACE_REFERENCES = [
    "Xrm.Page", //deprecated TODO lagonza user story 950152
    "Xrm.Utility",
    "Xrm.Panel",
    "Xrm.Device",
    "Xrm.Encoding",
    "Xrm.Navigation",
    "Xrm.WebApi"
];
const XRM_INTERNAL_REFERENCE = "Xrm.Internal";
const CRM_FORM_REFERENCE = "crmForm";
const MSCRM_REFERENCE = "Mscrm";

/**
 * Removes the specified characters from the start and end of the specified string.
 *
 * @param {string} s The string to process.
 * @param {Array} chars The characters to remove.
 * @returns {string} The trimmed string.
 */
function stringTrimAny(s, chars) {
    chars.forEach(function (c) {
        var regExp = new RegExp("^[" + c + "]+|[" + c + "]+$", "g");
        s = s.replace(regExp, "");
    });

    return s;
}

/**
 * Returns true if the specified string starts with any of the specified substrings; otherwise, false.
 *
 * @param {string} s The string to process.
 * @param {Array} strings The array of substrings.
 * @returns {boolean} `true` if the specified string starts with any of the specified substrings.
 */
function stringStartsWithAny(s, substrings) {
    return substrings.some(substr => s.startsWith(substr));
}

/**
 * Returns true if the specified string ends with any of the specified substrings; otherwise, false.
 *
 * @param {string} s The string to process.
 * @param {Array} strings The array of substrings.
 * @returns {boolean} `true` if the specified string ends with any of the specified substrings.
 */
function stringEndsWithAny(s, substrings) {
    return substrings.some(substr => s.endsWith(substr));
}

/**
 * Capitalizes the first letter of the specified string.
 *
 * @param {string} s The string to process.
 * @returns {string} The formatted string.
 */
function capitalizeString(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Replaces one or more numerical tokens in the specified string with corresponding string arguments.
 *
 * @param {string} s The string to process.
 * @returns {string} The formatted string.
 */
function formatString(s) {
    const args = Array.prototype.slice.call(arguments, 1);

    return s.replace(/{(\d+)}/g, function (match, number) {
        return typeof args[number] !== "undefined" ? args[number] : match;
    });
}

/**
 * Retrieves an array containing all strings (" or ') in the source code.
 *
 * @param {SourceCode} sourceCode - The source code of the analysis target.
 * @returns {ASTNode[]} An array of string nodes.
 */
function getAllStrings(sourceCode) {
    return sourceCode.ast.tokens.filter(token => (token.type === "String" ||
        (token.type === "JSXText" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === "JSXAttribute")));
}

/**
 * Checks a given node is a Identifier node of the specified name.
 *
 * @param {ASTNode} node - A node to check.
 * @param {string} name - A name to check.
 * @returns {boolean} `true` if the node is a Identifier node of the name.
 */
function isIdentifier(node, name) {
    return node && node.type === "Identifier" && node.name === name;
}

/**
 * Checks a given node is a Literal node of the specified string value.
 *
 * @param {ASTNode} node - A node to check.
 * @param {string} name - A name to check.
 * @returns {boolean} `true` if the node is a Literal node of the name.
 */
function isConstant(node, name) {
    switch (node.type) {
        case "Literal":
            return node.value === name;

        case "TemplateLiteral":
            return (
                node.expressions.length === 0 &&
                node.quasis[0].value.cooked === name
            );

        default:
            return false;
    }
}

/**
 * Checks a given node is a MemberExpression node which has the specified name's
 * property.
 *
 * @param {ASTNode} node - A node to check.
 * @param {string} name - A name to check.
 * @returns {boolean} `true` if the node is a MemberExpression node which has
 *      the specified name's property
 */
function isMember(node, name) {
    return (
        node.type === "MemberExpression" &&
        (node.computed ? isConstant : isIdentifier)(node.property, name)
    );
}

/**
 * Strips away opening and closing parens and everything in between
 * @param {string} expression 
 * @returns {string} Everything in the expression is returned without the parens and what is in between
 */
function getExpressionWithoutParens(expression) {
    if (expression) {
        return expression.replace(/\s*\(.*?\)\s*/g, '');
    }
    return expression;
}

function getVariableIndexByName(variables, name) {
    for (var i = 0; i < variables.length; i++) {
        if (variables[i].name === name) {
            return i;
        }
    }

    return -1;
}

function getVariableByName(variables, name) {
    const index = getVariableIndexByName(variables, name);
    return index > -1 ? variables[index] : null;
}

function getVariableNodeByName(variables, name) {
    const variable = getVariableByName(variables, name);
    return variable ? variable.identifiers[0] : null;
}

function getVariableLiteralValueByName(variables, name) {

    for (; ;) {
        const index = getVariableIndexByName(variables, name);
        const variable = variables[index];
        const init = variable.defs[0].node.init;

        switch (init.type) {
            case "Identifier":
                name === init.name;
                break;
            default:
                return init.value;
        }
    }
}

function removeWindowReferences(exprText) {
    const terms = ["window.opener.", "window.self.", "window.parent.parent.", "window.parent.", "parent.parent.", "opener.", "self.", "parent.", "window."];

    terms.forEach(function (term) {
        if (exprText.startsWith(term)) {
            exprText = exprText.substring(term.length);
        }
    });

    return exprText;
}

function getRootObjectName(node) {
    if (node.type === "MemberExpression") {
        while (node.object.type !== "Identifier") {
            node = node.object;

            if (!node.object) {
                return;
            }
        }

        return node.object.name;
    } else if (node.type === "Identifier") {
        return node.name;
    }
}

function getFullyQualifiedPropertyName(node, context, prependWindow) {
    let fqn = '';

    if (node.type === "Property") {
        let ancestors = context.getAncestors();

        while (ancestors.length > 0) {
            let currentNode = ancestors.pop();

            if (node.key && currentNode.type === "Property") {
                fqn = "." + currentNode.key.name + fqn;
            } else if (currentNode.id && currentNode.type === "VariableDeclarator") {
                // Assume rooted by the variable assignment
                fqn = currentNode.id.name + fqn;
                break;
            }
        }

        if (prependWindow && node.name !== "window") {
            fqn = "window." + fqn;
        }
    }

    return fqn;
}

function getFullyQualifiedFunctionName(node, prependWindow) {
    let fqn = "";

    if (node && node.type === "CallExpression") {
        while (node.type !== "Identifier" && (node.callee || node.property)) {
            if (node.callee) {
                node = node.callee;
            }

            if (node.property) {
                fqn = "." + node.property.name + fqn;
                node = node.object;
            }
        }

        if (node.name) {
            fqn = node.name + fqn;
        } else if (node.type === "ThisExpression") {
            fqn = "this" + fqn;
        }

        if (prependWindow && node.name !== "window") {
            fqn = "window." + fqn;
        }
    }

    return fqn;
}

function isHostedEnvironment(settings) {
    if (typeof settings === "object" && "isPowerAppsCheckerHosted" in settings) {
        return (settings.isPowerAppsCheckerHosted === true);
    }

    return false;
}

function reportAccordingly(context, node, messageId, data, snippet, fixer, suggest) {
    if (isHostedEnvironment(context.settings) === true) {
        context.report({
            node: node,
            message: JSON.stringify({
                messageId: messageId,
                data: data,
                snippet: snippet
            }),
            fix: fixer,
            suggest: suggest
        });
    }
    else {

        let dataAsDictionary = {};

        // Build the data dictionary param. In our case we do 0 based index as the key.
        if (typeof data !== 'undefined') {

            // Ensure that data passed is in an array. This allows it to be passed as a single value or an array.
            if (!Array.isArray(data)) {
                data = Array.of(data);
            }

            for (let index = 0; index < data.length; index++) {
                // Only add if it is not undefined. Any undefined should be at the end or it will lead to a strange index state.
                if (typeof data[index] !== undefined) {

                    // Create a property like this, "arg0", as you cannot have a property with a number starting the name. It appears to 
                    // treat this as an array indexer instead. ESLint does interpolation using the following, which fails when a number is passed.
                    // if (term in data) {
                    //     return data[term];
                    // }
                    dataAsDictionary[("arg" + index)] = data[index];
                }
            }
        }

        context.report({
            node: node,
            messageId: messageId,
            data: dataAsDictionary,
            fix: fixer,
            suggest: suggest
        });
    }
}

class usageTracker {
    constructor() {
        this._parentAssignmentVariables = {};
        this._documentObjectRefs = {};
        this._hasXrmSdkUsage = false;
        this._hasCrmInternalUsage = false;
        this._hasCrmFormSdkUsage = false;
    }

    get parentAssignmentVariables() {
        return this._parentAssignmentVariables;
    }

    isParentAssignmentVariable(nodeName) {
        return (nodeName.endsWith("window.parent")
            || nodeName.endsWith("document.parentWindow")
            || this._parentAssignmentVariables[nodeName]);
    }

    checkForParentAssignment(leftNode, rightNode, sourceCode) {
        if (leftNode && rightNode) {
            if (this.isParentAssignmentVariable(sourceCode.getText(rightNode))) {
                this._parentAssignmentVariables[leftNode.name] = true;
            }
        }
    }

    referencesParentWindow(node) {
        let result = false;

        if (node.type === "MemberExpression") {
            const rootObjectName = getRootObjectName(node);

            result = rootObjectName && (rootObjectName === "parent" || this.isParentAssignmentVariable(rootObjectName));
        }

        return result;
    }

    referencesWindow(node) {
        let result = false;

        if (node.type === "MemberExpression") {
            const rootObjectName = getRootObjectName(node);

            result = rootObjectName && (rootObjectName === "window" || this.referencesParentWindow(node));
        }

        return result;
    }

    isGlobalCall(node) {
        if (node.type === "Identifier") {
            return true;
        } else if (node.type === "MemberExpression") {
            return this.referencesWindow(node);
        }

        return false;
    }

    get documentObjectRefs() {
        return this._documentObjectRefs;
    }

    trackHtmlDomUsage(leftNode, rightNode) {
        if (leftNode && rightNode) {
            if (rightNode.type === "CallExpression") {
                rightNode = rightNode.callee;
            } else if (rightNode.type === "NewExpression") {
                return;
            }

            const rightName = rightNode.type === "Identifier" ? rightNode.name : (rightNode.property ? rightNode.property.name : undefined);

            if (rightName === "document" || this._documentObjectRefs[rightName]) {
                this._documentObjectRefs[leftNode.name] = true;
            }
        }
    }

    get hasXrmSdkUsage() {
        return this._hasXrmSdkUsage;
    }

    get hasCrmInternalUsage() {
        return this._hasCrmInternalUsage;
    }

    get hasCrmFormSdkUsage() {
        return this._hasCrmFormSdkUsage;
    }

    trackSdkUsage(node, sourceCode) {
        if (node) {
            switch (node.type) {
                case "Identifier":
                    if (node.name) {
                        if (!this.hasCrmFormSdkUsage && node.name === CRM_FORM_REFERENCE) {
                            this._hasCrmFormSdkUsage = true;
                        }

                        if (!this._hasCrmInternalUsage && node.name === MSCRM_REFERENCE) {
                            this._hasCrmInternalUsage = true;
                        }
                    }
                    break;
                case "MemberExpression": {
                    let exprText;

                    if (!this._hasXrmSdkUsage) {
                        exprText = sourceCode.getText(node);

                        for (const xrmSdkNamespace of XRM_SDK_NAMESPACE_REFERENCES) {
                            if (exprText.startsWith(xrmSdkNamespace)) {
                                this._hasXrmSdkUsage = true;
                                break;
                            }
                        }
                    }

                    if (!this.hasCrmInternalUsage) {
                        if (!exprText) {
                            exprText = sourceCode.getText(node);
                        }

                        if (exprText.endsWith(XRM_INTERNAL_REFERENCE)) {
                            this._hasCrmInternalUsage = true;
                        }
                    }
                    break;
                }
                case "CallExpression": {
                    if (!this._hasXrmSdkUsage) {
                        const exprText = sourceCode.getText(node);

                        for (const xrmSdkNamespace of XRM_SDK_NAMESPACE_REFERENCES) {
                            if (exprText.includes(xrmSdkNamespace)) {
                                this._hasXrmSdkUsage = true;
                                break;
                            }
                        }
                    }

                    break;
                }
            }
        }
    }
}

module.exports = {
    stringTrimAny,
    stringStartsWithAny,
    stringEndsWithAny,
    capitalizeString,
    formatString,
    getAllStrings,
    isIdentifier,
    isConstant,
    isMember,
    getVariableIndexByName,
    getVariableByName,
    getVariableNodeByName,
    getVariableLiteralValueByName,
    removeWindowReferences,
    getRootObjectName,
    getFullyQualifiedFunctionName,
    getFullyQualifiedPropertyName,
    isHostedEnvironment,
    reportAccordingly,
    getExpressionWithoutParens,
    usageTracker
}; 
