// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const xhrUtils = require("../utils/xhr-utils");
const ruleUtils = require("../utils/rule-utils");

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const MESSAGE_ID = "message2";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

function createSynchronousXhrMatch(definiteOrPotentialSyncCall, alternativeAPI) {
    return {
        definiteOrPotentialSyncCall: definiteOrPotentialSyncCall,
        alternativeApi: alternativeAPI
    };
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        type: "problem",

        docs: {
            description: "Interact with HTTP and HTTPS resources asynchronously",
            category: "error",
            recommended: true,
            url: "https://docs.microsoft.com/power-apps/maker/data-platform/powerapps-checker/rules/web/use-async"
        },

        fixable: "code",

        messages: {
            [MESSAGE_ID]: "'{{ arg0 }}' makes a synchronous server interaction. It is recommended that you convert this to an asynchronous call or utilize an API that makes an asynchronous call instead."
        }
    },

    create(context) {

        const sourceCode = context.getSourceCode();
        const syncCallDefinite = "calls";
        const syncCallPotential = "potentially calls";

        const falseVariables = {};
        const potentialFalseVariables = {};
        const xmlHttpRequestInstances = {};
        const dictionaries = [falseVariables, potentialFalseVariables, xmlHttpRequestInstances];

        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------

        function evaluateSyncXHRJavascriptJQuery(args, isJQuery) {
            let match = null;

            if (!isJQuery && args) {
                if (args.length > 2) {
                    const arg = args[2];

                    if (arg.type === "Literal"
                        && !arg.value) {
                        match = createSynchronousXhrMatch(syncCallDefinite, null);
                    } else if (arg.type === "Identifier") {
                        if (falseVariables[arg.name] === true || arg.name === "undefined") {
                            match = createSynchronousXhrMatch(syncCallDefinite, null);
                        } else if (potentialFalseVariables[arg.name] === true) {
                            match = createSynchronousXhrMatch(syncCallPotential, null);
                        }
                    } else if (arg.type === "CallExpression") {
                        if (falseVariables[arg.callee.name] === true) {
                            match = createSynchronousXhrMatch(syncCallDefinite, null);
                        } else if (potentialFalseVariables[arg.callee.name] === true) {
                            match = createSynchronousXhrMatch(syncCallPotential, null);
                        }
                    }
                }
            } else if (isJQuery && args && args.length > 0) {
                const paramObject = args[0];

                if (paramObject.properties) {
                    paramObject.properties.forEach(function (prop) {
                        if (prop.key && prop.key.name === "async") {
                            if (prop.value.type === "Literal" && prop.value.value === false) {
                                /*
                                 * { async: false }
                                 */
                                match = createSynchronousXhrMatch(syncCallDefinite, null);
                            } else if (prop.value.type === "Identifier") {
                                /*
                                 * var useAsync = false;
                                 * { async: useAsync }
                                 */
                                if (falseVariables[prop.value.name] === true) {
                                    match = createSynchronousXhrMatch(syncCallDefinite, null);
                                } else if (potentialFalseVariables[prop.value.name] === true) {
                                    match = createSynchronousXhrMatch(syncCallPotential, null);
                                }
                            } else if (prop.value.type === "CallExpression") {
                                if (falseVariables[prop.value.callee.name] === true) {
                                    match = createSynchronousXhrMatch(syncCallDefinite, null);
                                } else if (potentialFalseVariables[prop.value.callee.name] === true) {
                                    match = createSynchronousXhrMatch(syncCallPotential, null);
                                }
                            }
                        }
                    });
                }
            }

            return match;
        }

        function evaluateSyncExternalLibraryCall(node) {
            let match = null;
            const funcName = node.property.name;
            let parentStack = sourceCode.getText(node);
            parentStack = parentStack.substr(0, parentStack.lastIndexOf("."));
            parentStack = parentStack.replace("window.").replace("parent.");

            if (
                funcName in xhrUtils.xrmServiceToolkitRestMethods
                && parentStack === xhrUtils.xrmServiceToolkitRestApi
            ) {
                match = evaluateParamsRestXrmServiceToolkit(funcName, node.parent.arguments);

                if (match) {
                    match.AlternativeApi = xhrUtils.xrmServiceToolkitRestMethods[funcName];
                    return match;
                }
            }

            if (
                funcName in xhrUtils.xrmServiceToolkitSoapMethods
                && parentStack === xhrUtils.xrmServiceToolkitSoapApi
            ) {
                match = evaluateSyncParamsSoapXrmServiceToolkit(funcName, node.parent.arguments);

                if (match) {
                    match.AlternativeApi = xhrUtils.xrmServiceToolkitSoapMethods[funcName];
                    return match;
                }
            }

            if (
                funcName in xhrUtils.xrmServiceToolkitSoapSyncMethods
                && parentStack === xhrUtils.xrmServiceToolkitSoapApi
            ) {
                return createSynchronousXhrMatch(syncCallDefinite, xhrUtils.xrmServiceToolkitSoapMethods[funcName]);
            }

            if (
                funcName in xhrUtils.soapSDKSynchronousMethods
                && parentStack === xhrUtils.syncSoapSdkApi
            ) {
                return createSynchronousXhrMatch(syncCallDefinite, xhrUtils.soapSDKSynchronousMethods[funcName]);
            }

            return match;
        }

        function evaluateParamsRestXrmServiceToolkit(funcName, args) {
            if (args && args.length > 3) {
                let syncParam = 0;

                switch (funcName) {
                    case "Create":
                    case "Delete":
                        // Fifth parameter is async designation
                        syncParam = 4;
                        break;
                    case "Retrieve":
                    case "Disassociate":
                        // Seventh parameter is async designation
                        syncParam = 6;
                        break;
                    case "Update":
                    case "RetrieveMultiple":
                        // Sixth parameter is async designation
                        syncParam = 5;
                        break;
                    case "Associate":
                        // Eighth parameter is async designation
                        syncParam = 7;
                        break;
                    default:
                        return null;
                }

                const asyncArg = args[syncParam];

                if (
                    args.length === syncParam
                    || (asyncArg.type === "Literal" && asyncArg.value === false)
                    || (asyncArg.type === "Identifier" && falseVariables[asyncArg.name] === true)
                ) {
                    return createSynchronousXhrMatch(syncCallDefinite, null);
                }
            }

            return null;
        }

        function evaluateSyncParamsSoapXrmServiceToolkit(funcName, args) {
            if (args && args.length > 0) {
                let syncParam = 0;

                switch (funcName) {
                    // Second parameter is async designation
                    case "Create":
                    case "Update":
                    case "Execute":
                    case "RetrieveMultiple":
                    case "QueryByAttribute":
                    case "QueryAll":
                    case "GrantAccess":
                    case "ModifyAccess":
                    case "RevokeAccess":
                    case "RetrievePrincipalAccess":
                        syncParam = 1;
                        break;

                    // Third parameter is async designation
                    case "Delete":
                    case "Fetch":
                    case "RetrieveAllEntitiesMetadata":
                        syncParam = 2;
                        break;

                    // Fourth parameter is async designation
                    case "Retrieve":
                    case "RetrieveEntityMetadata":
                    case "RetrieveAttributeMetadata":
                        syncParam = 3;
                        break;

                    // Fifth parameter is async designation
                    case "SetState":
                    case "Assign":
                        syncParam = 4;
                        break;

                    // Sixth parameter is async designation
                    case "Associate":
                    case "Disassociate":
                        syncParam = 5;
                        break;

                    default:
                        return null;
                }

                if (syncParam === 0) {
                    return null;
                }

                if (args.length <= syncParam) {
                    return createSynchronousXhrMatch(syncCallDefinite, null);
                } else {
                    const asyncArg = args[syncParam];

                    if ((asyncArg.type === "Literal" && asyncArg.value === null)
                        || (asyncArg.type === "Identifier" && asyncArg.name === "undefined")) {
                        return createSynchronousXhrMatch(syncCallDefinite, null);
                    }
                }
            }

            return null;
        }

        function evaluateExpressionTerms(node, object) {
            switch (object.type) {
                case "Literal":
                    // var x = false;
                    if (object.value === false) {
                        if (node.id) {
                            falseVariables[node.id.name] = true;
                        } else if (node.parent.id) {
                            falseVariables[node.parent.id.name] = true;
                        }
                    }
                    break;
                case "Identifier":
                    if (xhrUtils.isJavaScriptXMLHttpRequest(node.init)) {
                        xmlHttpRequestInstances[node.id.name] = true;
                    } else {
                        /*
                        * var x = false;
                        * var y = x;
                        */
                        var nodeId = node.id ? node.id : node.parent.id;

                        if (nodeId) {
                            dictionaries.forEach(function (d) {
                                evaluateExpressionTermsForDictionary(nodeId.name, object.name, d);
                            });
                        }
                    }
                    break;
                case "BinaryExpression":
                    if (node.type !== "FunctionExpression") {
                        /*
                        * var x = 5;
                        * var y = x > 10;
                        */
                        potentialFalseVariables[node.id.name] = true;
                    }
                    break;
                default:
                    if (xhrUtils.isJQueryXMLHttpRequest(object)) {
                        reportIfSyncXhrMatchFound(node, object.arguments, true);
                    } else if (xhrUtils.isJavaScriptXMLHttpRequest(object)) {
                        if (node.id) {
                            xmlHttpRequestInstances[node.id.name] = true;
                        } else {
                            var ancestorStack = context.getAncestors();

                            // Seek first var declaration, assignment, or property in the stack
                            while (ancestorStack.length > 0) {
                                var currentNode = ancestorStack.pop();

                                if (currentNode.type === "VariableDeclarator") {
                                    xmlHttpRequestInstances[currentNode.id.name] = true;
                                }
                                else if (currentNode.type === "Property") {
                                    let fqPropName = ruleUtils.getFullyQualifiedPropertyName(currentNode, context);
                                    xmlHttpRequestInstances[fqPropName] = true;
                                    break;
                                } else if (currentNode.type === "AssignmentExpression") {
                                    let fqTargetName = xhrUtils.getFullyQualifiedMemberExpressionName(currentNode.left);
                                    xmlHttpRequestInstances[fqTargetName] = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
            }
        }

        function evaluateExpressionTermsForDictionary(left, right, dictionary) {
            if (dictionary[right] === true) {
                dictionary[left] = true;
            }
        }

        function evaluateFunctionExpression(node) {
            for (var i = 0; i < node.body.body.length; i++) {
                const bodyOp = node.body.body[i];
                if (bodyOp.type === "ReturnStatement" && bodyOp.argument) {
                    evaluateExpressionTerms(node, bodyOp.argument);
                }
            }
        }

        function reportIfSyncXhrMatchFound(callOrigin, callArgs, isJquery) {
            const match = evaluateSyncXHRJavascriptJQuery(callArgs, isJquery);
            const snippet = sourceCode.getText(callOrigin);

            if (match) {
                ruleUtils.reportAccordingly(
                    context,
                    callOrigin,
                    MESSAGE_ID,
                    [snippet],
                    snippet
                );
            }
        }

        function reportIfSyncExternalLibraryCall(node) {
            const match = evaluateSyncExternalLibraryCall(node);
            const snippet = sourceCode.getText(node);

            if (match) {
                ruleUtils.reportAccordingly(
                    context,
                    node,
                    MESSAGE_ID,
                    [snippet],
                    snippet
                );
            }
        }

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return {
            VariableDeclarator(node) {
                if (node.init) {
                    evaluateExpressionTerms(node, node.init);
                }
            },
            "FunctionDeclaration:exit"(node) {
                if (node.body) {
                    evaluateFunctionExpression(node);
                }
            },
            FunctionExpression(node) {
                evaluateFunctionExpression(node);
            },
            AssignmentExpression(node) {
                if (falseVariables[node.right.name] === true) {
                    // The right operand is in the list, so add the left operand as well
                    falseVariables[node.left.name] = true;
                } else if (
                    falseVariables[node.left.name] === true
                    && (!falseVariables[node.right.name] || node.right.value !== false)
                ) {
                    // The left operand is in the list, but the right is not, OR it's a literal !== false, so remove the key
                    falseVariables[node.left.name] = null;
                } else if (
                    potentialFalseVariables[node.left.name] === true
                    && node.right.value === false
                ) {
                    // The left operand is in the potentials list, and assigning literal false, so move the variable from potential to definite
                    potentialFalseVariables[node.left.name] = null;
                    falseVariables[node.left.name] = true;
                } else {
                    let fqRightName = node.right.type === "MemberExpression"
                        ? xhrUtils.getFullyQualifiedMemberExpressionName(node.right)
                        : node.right.name;
                    let fqLeftName = node.left.type === "MemberExpression"
                        ? xhrUtils.getFullyQualifiedMemberExpressionName(node.left)
                        : node.left.name;

                    if (
                        (node.right.type === "NewExpression" && node.right.callee.name === "XMLHttpRequest")
                        || xmlHttpRequestInstances[fqRightName] === true
                    ) {
                        // The right operand is a new XMLHttpRequest or already in the list, so add the left operand as well
                        xmlHttpRequestInstances[fqLeftName] = true;
                    } else if (
                        xmlHttpRequestInstances[fqLeftName] === true
                        && (!xmlHttpRequestInstances[fqRightName] || node.right.value !== false)
                    ) {
                        // The left operand is in the list, but the right is not, OR it's a literal !== false, so remove the key
                        delete xmlHttpRequestInstances[fqLeftName];
                    }
                }
            },
            CallExpression(node) {
                if (node.parent.id) {
                    if (falseVariables[node.callee.name] === true) {
                        /*
                        * var isAsync = getIsAsync(); (function returns false)
                        */
                        falseVariables[node.parent.id.name] = true;
                    } else if (potentialFalseVariables[node.callee.name] === true) {
                        /*
                        * var isAsync = getIsAsync(); (function returns unknown boolean)
                        */
                        potentialFalseVariables[node.parent.id.name] = true;
                    }
                } else {
                    /*
                    * Special case
                    * $.ajaxSetup({ async: false });
                    */
                    var name = xhrUtils.getFullyQualifiedMemberExpressionName(node.callee);

                    if (name === "$.ajaxSetup") {
                        reportIfSyncXhrMatchFound(node, node.arguments, true);
                    }
                }
            },
            MemberExpression(node) {
                if (ruleUtils.isIdentifier(node.property, "open")) {
                    let shouldInspectInstance = false;

                    switch (node.object.type) {
                        case "Identifier":
                            /*
                            * xhr.open("GET", "/test/test.txt", false);
                            */
                            shouldInspectInstance = xmlHttpRequestInstances[node.object.name];
                            break;
                        case "MemberExpression": {
                            /*    
                            * foo.bar().xhr.open("GET", "url", false);
                            */
                            let fqMemberName = xhrUtils.getFullyQualifiedMemberExpressionName(node.object);
                            shouldInspectInstance = xmlHttpRequestInstances[fqMemberName];
                            break;
                        }
                        case "CallExpression": {
                            /*    
                            * xhr().open("GET", "url", false); 
                            */
                            let fqCallName = ruleUtils.getFullyQualifiedFunctionName(node.object);
                            shouldInspectInstance = xmlHttpRequestInstances[fqCallName];
                            break;
                        }
                        case "NewExpression":
                            /*
                            * new XMLHttpRequest().open("GET", "/test/test.txt", false);
                            */
                            shouldInspectInstance = node.object.callee && node.object.callee.name === "XMLHttpRequest";
                            break;
                    }

                    if (shouldInspectInstance) {
                        reportIfSyncXhrMatchFound(node, node.parent.arguments, false);
                    }
                } else if (xhrUtils.isExternalLibraryCall(node)) {
                    reportIfSyncExternalLibraryCall(node);
                }
            }
        };
    }
};
